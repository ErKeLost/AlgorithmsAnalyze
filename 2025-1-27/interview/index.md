# 八股

## 网络

### - get 和 post 的区别

传递参数不同 Post 传递的参数在 Request Body 中 get 在 url 后拼接
get 请求一半用于查询 post 用于修改操作

本质上都是 tcp 链接 没有本质区别

get 主要用于获取数据 post 主要用于提交数据

get 参数有长度限制 post 理论上没有限制

get 请求参数会暴露在 url 上 安全性不如 post

get 请求参数会被浏览器主动缓存 post 不会

get 请求参数会被保留在浏览器历史记录中 post 不会

get 请求参数会被保留在浏览器历史记录中 post 不会

- HTTP 1.1 和 HTTP 2.0 的区别

1. 多路复用 http1 解析基于文本 http2 基于二进制
2. 头部压缩 http1 每次请求都会携带完整的头部信息 http2 会压缩头部信息 差量更新
3. 服务器推送 http1 需要客户端请求 http2 在客户端请求之前主动推送资源 只能发 css 和 img 等静态资源

- HTTP 和 HTTPS 协议的区别

HTTP 是超文本传输协议 信息是明文传输 HTTPS 是加密传输 需要到 CA 申请证书 会加密

http 直接跟 tcp 通信 https 通信在 tcp 之间加入了 ssl 层 用于数据加密

http 端口号 80 https 端口号 443

安全性 http 明文传输 不安全 https 加密传输 安全

### - 三次握手和四次挥手

seq 序列号 随机数 seq = x 每次连接都会携带一个自己的随机序列号
ack 确认号 ack = seq + 1 确认上一次收到了序列号 除了第一次连接都会携带
ACK 确认收到序列号 ACK = 1 除了第一次连接都会携带
SYN 发起一个新连接 SYN = 1
FIN 释放一个连接 FIN = 1

三次握手 建立连接

1. 客户端 -》服务器 我要链接你 发你 SYN 链接 seq = x 序列号 进入 SYN_SEND 状态

客户端给服务器发送 tcp 报文 向服务器请求链接

- 创建一个 SYN = 1 的新链接 然后 发送暗号 seq = x 的随机序列号 然后客户端处理 SYN—SEND 状态 就是我发完了 然后我问你 我说你听见了么

- 服务器送到 SYN 报文之后 创建一个 SYN = 1 的新链接 SEQ = Y 的随机序列号 然后 带一个 ACK = 1 确认 啊 我收到你刚才给我发的虚列好了 ack = x + 1 确认号 然后服务器处理 SYN_RCVD 状态 就是我收到你刚才给我发的虚列好了 ack = x + 1 确认号 然后我问你 我说你听见了么

- 然后我客户端收到报文之后回复服务器 啊 我收到了 ACK = 1 确认我收到了 然后继续发回去 seq 和 ack 然后客户端处理 ESTABLISHED 状态 就是我收到你刚才给我发的虚列好了 ack = x + 1 确认号 然后俩人都知道自己收到对方确认了 然后就建立链接了

2. 服务器 -》客户端 好的 我准备好了 然后 SYN = 1 ACK = x+1 确认号 ACK 除了第一次都会携带 进入 SYN_RCVD 状态
3. 客户端 -》服务器 我也准备好了 然后 ACK = y+1 确认号 进入 ESTABLISHED 状态

类似于打电话

1. 开始打电话
2. 喂 听到了么 第一次
3. 听到了 你听到了么 第二次
4. 听到了 挂了 第三次

四次挥手 断开连接

1. 客户端 -》服务器 我要断开连接 发你 FIN 链接 seq = x 序列号 进入 FIN_WAIT_1 状态
2. 服务器 -》客户端 好的 我准备好了 然后 ACK = x+1 确认号 进入 CLOSE_WAIT 状态
3. 服务器 -》客户端 我要断开连接 发你 FIN 链接 seq = y 序列号 进入 LAST_ACK 状态
4. 客户端 -》服务器 好的 我准备好了 然后 ACK = y+1 确认号 进入 TIME_WAIT 状态 等待 2MSL 后进入 CLOSED 状态

类似打电话

1. 我要挂了啊
2. 好的 我知道了
3. 我也要挂了啊
4. 好的 我知道了拜拜

为什么要三次握手

1. 要保证双方都有发送和接受数据的能力
2. 防止历史链接的建立
3. 同步双方序列号

为什么要四次挥手

1. 因为 tcp 是全双工通信 需要双方都确认断开链接
2. 每个链接都需要单独关闭

3. 第一次挥手 向服务器发送报文 FIN = 1 发送关闭链接 SEQ = u 随机序列号 然后这时候浏览器进入 FIN_WAIT_1 状态 半关闭状态
4. 第二次挥手 服务器收到了 然后知道浏览器要关闭链接了 所以要处理内部操作
   ACK = 1 确认收到序列号 act = u + 1 确认号 然后服务器进入 CLOSE_WAIT 状态 半关闭状态 FIN—WAIT-2
5. 第三次挥手 服务器处理完毕 然后通知浏览器 FIN = 1 关闭链接 SEQ = v 随机序列号 然后服务器进入 LAST_ACK 状态 半关闭状态 等待浏览器确认收到
6. 第四次挥手 浏览器收到服务器发送的 FIN 报文之后 知道服务器已经处理完毕 然后回复服务器 ACK = 1 确认收到序列号 act = v + 1 确认号 然后浏览器进入 TIME_WAIT 状态 等待 2MSL 后进入 CLOSED 状态

- 当在浏览器中输入 URL 并且按下回车之后发生了什么？

url 解析 判断 url 是否符合规范 浏览器判断请求资源是否有缓存

dns 解析获取目标服务器 ip 地址

建立 tcp 链接 三次握手

发送 http 请求

服务器处理请求并返回 http 响应

浏览器解析渲染页面

tcp 链接关闭 四次挥手

然后这块就有两个知识点

### 1. 浏览器缓存

缓存分类

- 强缓存 不需要发送请求到服务器 直接使用本地缓存 可以通过 header 信息中的 expires 和 cache-control 来设置

1. Expires 过期时间 服务器返回的资源过期时间 如果还没过期 则直接使用本地缓存
   已过时 使用 cache-control 替代

Expires: Wed, 29 Jan 2025 08:00:00 GMT

2. Cache-Control 过期时间 服务器返回的资源过期时间 如果还没过期 则直接使用本地缓存

Cache-Control: max-age=604800 表示资源在 7 天内有效

Cache-Control: no-cache 表示资源需要通过服务器验证是否过期

Cache-Control: no-store 表示资源需要通过服务器验证是否过期

Cache-Control: private 表示资源需要通过服务器验证是否过期

Cache-Control: public 表示资源需要通过服务器验证是否过期

Cache-Control: must-revalidate 表示资源需要通过服务器验证是否过期

Cache-Control: proxy-revalidate 表示资源需要通过服务器验证是否过期

Cache-Control: s-maxage=604800 表示资源在 7 天内有效 但是是代理服务器缓存

Cache-Control: immutable 表示资源不会改变

- 协商缓存 需要发送请求到服务器 服务器判断是否使用本地缓存 可以通过 header 信息中的 last-modified 和 etag 来设置

1. Last-Modified 最后修改时间 服务器返回的资源最后修改时间 如果资源没有改变 则直接使用本地缓存

2. ETag 唯一标识 服务器返回的资源唯一标识 如果资源没有改变 则直接使用本地缓存
   基于文件内容

```ts
// index.html 使用协商缓存
Response Headers:
Cache-Control: no-cache
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
ETag: "33a64df551425fcc55e4d42a148795d9"

// 结果：每次请求都会询问服务器文件是否改变
// 如果未改变，返回 304 状态码
// Chrome Network 面板显示：304
```

### 什么是 HTTPS 协议？如何加密的？

# 浏览器

- XSS 跨站脚本攻击

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

比如 cookie 使用 http-only

对用户输入的地方和变量都需要仔细检查长度和对 ”<”,”>”,”;”,”’” 等字符做过滤

- CSRF（跨站请求伪造）

比如银行请求, 用户在银行发送了转账请求, 然后存了 cookie 然后小明点了一个链接 然后发送了请求 就转账了 芜湖

简单来说：
用户已经登录了网站 A
用户访问了黑客的网站 B
网站 B 向网站 A 发送请求
浏览器会自动带上网站 A 的 Cookie
网站 A 以为是用户本人的操作
就像：
你的朋友拿着你的银行卡（Cookie）
去银行取钱（发送请求）
银行以为是你本人（验证 Cookie 通过）

防御

- SameSite Cookie

```ts
// 设置 Cookie 的 SameSite 属性
Set-Cookie: sessionId=abc123; SameSite=Strict

// Strict: 完全禁止第三方网站发送 Cookie
// Lax: 允许部分第三方请求（如链接跳转）发送 Cookie
// None: 允许所有第三方请求发送 Cookie（需要配合 Secure）
```

- 验证码

- 验证 referer

### Http 状态码

```ts
const httpStatus = {
  "1xx": "信息响应",
  "2xx": "成功响应",
  "3xx": "重定向",
  "4xx": "客户端错误",
  "5xx": "服务器错误",
};

// 最常见的状态码
const commonStatus = {
  200: "OK - 请求成功",
  301: "永久重定向",
  302: "临时重定向",
  304: "Not Modified - 资源未修改",
  400: "Bad Request - 请求语法错误",
  401: "Unauthorized - 未授权",
  403: "Forbidden - 禁止访问",
  404: "Not Found - 资源不存在",
  500: "服务器内部错误",
  502: "Bad Gateway - 网关错误",
  503: "服务暂时不可用",
  504: "Gateway Timeout - 网关超时",
};
```

### DNS 完整查询过程

- 查看浏览器缓存是否有对应 IP，如果找到直接返回，没有找到继续下一步。
- 发送请求到本地 DNS 服务器，本地域名服务器缓存中如果有，直接返回，没有就向上级服务器迭代查询。
- 本地 DNS 服务器向根域名服务器发送请求，根域名服务器会返回一个顶级域名服务器地址。
- 本地 DNS 服务器向顶级域名服务器发送请求，顶级域名服务器查询自己的缓存，如果就返回，如果没有返回下一级权威域名服务器地址。
- 本地 DNS 服务器向权威域名服务器发送请求，服务器返回域名对应的 ip
- 本地 DNS 服务器将返回结果保存，方便下次查询。
- 本地 DNS 服务器将 IP 返回给浏览器

### OSI 七层模型

- 物理层
- 数据链路层
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层

### TCP 和 UDP 的区别
